203. Remove Linked List Elements

ELABORATION:

We have got a linked list, and we want to remove each and every node that its value is equal to the demanded value. Easy one. 

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
    
    // We have got make sure that the first node in the linked list is not a nullptr
    // If it is, then there is nothing do in here, lol
    if(!head) return head;
    
    // We want to make sure we remove every node that is equal to the val.
    
    while(head && head->value == val){
    head = head->next;
    }
    
    // So, we have removed (skipped) every node that is equal to the val.
    // temp pointer now points at the first node (after the removal of other nodes)
    ListNode*  temp = head; 
    
    while(temp){
    if( temp-> next && temp->next->val == val){
    temp->next-> = temp->next->next;
    } else {
    temp = temp->next;
    }
    
    return head;
    }
    
    So, the leasson learnt from this LeetCode question is:
    
    We don't actually delete a node, we actually skip this node and set the head to the next node. Also, we need to make sure every time that the node is not a nullptr.
    This trick I always forget, lol. 
    
    }
    
    
    
    876. Middle of the Linked List
    
    I have used the two-pointer technique in order to puzzle out this problem. Actually, this algorithm can be used to get the middle element of any array. Nick White, thank you bro. 
    
    /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
    
    // two pointers 
    ListNode* first = head;
    ListNode* second = head;
    
    while(second && second-> next ){
    first = first-> next;
    second = second->next -> next;
    }
    
    return first;
    }
    
    This algorithm is so great in getting the middle element in any array, using the two-pointer technique (the nested loop techenique is bad, my peeps)
    
    We create two pointers which are first and second. As long as second isn't nullptr, nor the next node, we keep looping.
    
    As long as we loop through the linked list. The first pointer points to the next node, while the second pointer points to the next's next. 
    
    So, when the second pointer stops, the first pointer will be at the middle element. Try it out in a piece of paper to fully comprehend this algorithm.
    
    
    
    
    83. Remove Duplicates from Sorted List
    
    /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
   
  
   ListNode* temp = head;
   
   while(temp & temp -> next){
   // if the current node's value is equal to the next node's value, we remove the next node's value
   if(temp->val == temp->next->val){
   //delete the next value
   temp->next = temp->next->next;
   } else {
   //else traverse noramlly 
   temp = temp->next;
   }
   }
    
  }
  
  
  21. Merge Two Sorted Lists
  
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
     
//     We are creating a new linked list to push inside of it nodes in a sorted way
        ListNode* temp = new ListNode(0);
//         current is used to traverse inside of the linked list
        ListNode* current = temp;
        
//         as long as list1 & list2 aren't nullptrs 
        while(list1 && list2){
//         list1 and list2 represent two linked lists and also the head of each list
            if(list1->val < list2->val){
                current->next = list1;
                list1 = list1->next;
            } else {
                current-> next = list2;
                list2 = list2->next;
            }
            
//      If list1's value is less than list2's, add it to the temp_node's linked list
//      So, it can be sorted
            
            current = current->next;
            
//      Once we push the node inside, we traverse the current ptr to the newly-added-node
            
            
        }
//         In the if condition there is a problem which is
//         the while condition could stop with finishing off one of the linked lists
//         So, we've got to make sure one of the linked lists is finished off
        
        if(list1){
            current->next = list1;
            list1 = list1->next;
        }
        
        if(list2){
            current->next = list2;
            list2 = list2-> next;
        }
        
//         return the head which represents the linked list;
        
        return temp->next;
    }
    
};
    
    
  
  
  ------- 
  
  I'd like to summarize what I've learnt from these LeetCode questions (to be continued) :
  
  a) I have learnt that the removal of a node means actually skipping a node, by making the current node equals to its next node.
       And we, now, know how to remove a node with a specific value, but this is not the concept of this question. The main concept is,
       learning how to remove a node whatever the case is. 
       
  b) We have learnt how to get the middle node with the two-pointer technique, there is this algorithm that I've learnt from Nick White. 
      Set two pointers, one which movies only one step and the other moves two steps forward. When the second finishes, the first one will stop
      at the middle node. Thanks bro, again.
  
  c) Removing the duplicated node from the linked list. I puzzled it out as a reason of understanding the concept of deleteting a node. 
      We remove the second duplicated node in the array if the first and second are duplicated. That is it. If this doesn't match, we traversal
      to the next node and check if its next is the same. 
      
      
      
      Haha, I recall my conversation with my friend, Zoma. I used to tell him how I detest the Linked List data structure. Back then, I couldn't understand why. 
        But now, I do. It's because of the ptr concept people. I don't know how software developers should understand Linked List without studying a structured
        programming language. Linked List is based on ptrs, lol.
        
        
  
  
